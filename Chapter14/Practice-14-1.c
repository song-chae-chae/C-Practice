#include <stdio.h>
// 메모리 구조

// 코드 영역 : 실행 명령어 저장
// 소스코드가 저장되는 영역으로 컴퓨터가 실행해야 할 명령어들이 순서대로 쌓이는 메모리 영역
// 프로그램을 실행시키면 CPU가 알아서 코드 영역에 저장된 명령어들을 하나씩 가져가 처리

// 스택 영역 : 지역변수 및 매개변수 저장
// 스택 : 모든 원소들의 삽입 삭제를 리스트의 한쪽 방향에서만 수행되도록 하는 제한 조건을 가진 선형 자료구조
//        출입구가 한 곳이라 데이터가 들어온 곳으로부터 다시 나가는 구조 (Last In First Out)
//		  함수 안에서 사용했던 지역 변수, 매개 변수 등

// 힙 영역 : 프로그래머가 직접 할당
// 힙 : 컴퓨터 메모리의 일부가 할당되었다가 회수되는 일들이 반복되는 것
// 프로그래머가 필요에 의해 그 즉시 메모리를 할당하다 보니, 블록의 크기나 요구 및 횟수 순서가 일정한 규칙이 없는 특징
// 코드의 컴파일 시 할당하는 메모리가 아니라 프로그램 실행 시 사용자로부터 할당하고자 하는 메모리를 입력받는 것이므로 미리 메모리 공간 예측 불가

// 데이터 영역 : 전역변수, static 변수 저장
// 전역, static 변수들이 저장되는 메모리 영역
// 전역 변수 : 함수 외부에 선언
// static 변수 : 지역 변수처럼 선언되지만, 함수가 종료되어도 소멸되지 않는 특징
// 전역, static의 공통점 : 함수 영역에 전혀 구애 받지 않는 것
// 전역 변수 -> 함수 외부에 선언되어 있으므로 프로그램 시작할 때 생성, 프로그램이 끝날 때 소멸
// static 변수 -> 선언한 위치에서 메모리 생성, 프로그램 끝날 때 소멸
// 둘 다 함수에 종속적이지 않고, 프로그램의 필요에 따라 언제든 호출이 가능해야 하므로 메모리를 구분하여 데이터 영역에 저장, 사용

int g_a;
int g_b;

int f1(int c);
int f2(int d);

void main() {
	int h = 10;
	g_a = f1(h);
	g_b = f2(h);

	printf("g_a = %d, g_b = %d\n", g_a, g_b);
}

int f1(int c) {
	int e = 10;
	return e + c;
}

int f2(int d) {
	int f = 20;
	return f + d;
}

// 위 프로그램의 메모리 흐름
// 1. 프로그램의 시작과 전역 변수의 저장
// g_a, g_b 선언함으로써 프로그램 시작 시 데이터 영역에 두 전역 변수 저장

// 2. main 함수 시작
// int h 선언 -> 스택 메모리에 가장 먼저 변수 h 올라감

// 3. f1 함수 호출, 완료
// 함수 호출 시 해당 함수로 점프하여 f1 함수 수행
// 스택 메모리의 처음에 올라간 변수 h 위에 매개변수 int c가 올라가고
// f1 함수 내에서 선언한 변수 e가 올라감
// 값을 리턴하고 f1 함수를 종료하면서 스택 메모리 상에서 e, c는 소멸됨

// 4. f2 함수 호출, 완료
// 스택 메모리에 매개변수 int d가 올라가고
// f2 함수 내에서 선언한 변수 f 올라감
// f2 함수 종료하면서 f, d 소멸됨

// 5. main 함수의 종료 및 프로그램 종료
// printf를 통해 전역 변수 값 출력
// 이때 f1, f2 안에서 선언했던 모든 매개, 지역변수들은 소멸된 상태이고
// main 함수 내에서 선언한 변수 h, 전역변수 g_a, g_b만 유효
// main 함수 종료 -> h 변수 스택 메모리에서 소멸되고
// 전역 변수만 저장되어 있는 데이터 영역은 그대로 유지됨
// 프로그램 종료될 때 데이터 영역 비워짐